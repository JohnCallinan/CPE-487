# CPE-487 Snake Game Project

## Description of the Expected Behavior

The expected behavior of the project follows what one would expect from the game snake. There is a user controlled snake that is able to move around the screen on a fixed grid. The user should be allowed to move the snake up, down, left, or right with the direction that is the direct opposite of the current direction being blocked. The users goal is to move and collect balls which spawn randomly on the screen. The randomness is driven by constantly running through a table of pseudo-random numbers and picking a set of numbers to use as the coordinates to spawn the ball. When the user puts the head of the snake on a ball three things should happen: first the counter on the board should increase by one, next the snake's length should grow, and finally the ball should spawn in a random location. The snakes length is controlled by an array, set to the max size allowed for the snake, when the snake is supposed to grow the next set of values in the array are flipped into a high state. When the snake is drawn onto the board we check which values are in the high state and draw those parts of the snake, so if the first 20 elements of the array are high we draw the snake 20 elements long. As the snake grows the challenge becomes to continue collecting these balls while avoiding colliding with the walls or yourself. This collision works by checking the position of the snake's head, if the head ever comes passes the designated thresholds for the walls or overlaps with the body positions then the game ends. When the game ends we have to reset everything, we do this by having a reset flag that gets triggered by any of the collisions. When the reset flag is set it places the ball and snake into the default positions, reduces the snake's size to default, resets the counter, and then flips all flags back to low to avoid being stuck in a reset. All of these features allow us to have a game the functions nearly identical to the classic game snake while running on the fpga.

## How to Run the Project

### 1. Create a new RTL project pong in Vivado Quick Start
* Create seven new source files of file type VHDL called clk_wiz_0, clk_wiz_0_clk_wiz, vga_sync, bat_n_ball, leddec16, rng_table and pong
* Create a new constraint file of file type XDC called **_pong_**
* Choose Nexys A7-100T board for the project
* Click 'Finish'
* Click design sources and copy the VHDL code from clk_wiz_0, clk_wiz_0_clk_wiz, vga_sync.vhd, bat_n_ball.vhd, leddec16.vhd, rng_table.vhd pong.vhd
* Click constraints and copy the code from pong.xdc

### 2. Run synthesis

### 3. Run implementation

### 4. Generate bitstream, open hardware manager, and program device

### 5. Use the BTNU, BTND, BTNL, and BTNR buttons to control the snakes movment

## Inputs and Outputs

Since the original code we modified was lab 6: pong, a majority of the inputs and outputs needed were already there for us. By default we had the clock, VGA vsync and colors, LED segments, LED annode, as well as buttons for left, right and center. However, since our project required 2d movement, we had to add the ports for buttons up and down. Originally we had a lot of new inputs that needed to be put into the xdc, however we were able to eliminate all of them and make the code much more optimized and less hardware intensive.

## Video of Project

[Link to Video](https://youtu.be/i8obphgsEuc)

## Modifications

The basis of our code is based on the pong code from lab 6, however there were a lot of modifications made to change it to be our snake game. The leddec16, clk_wiz_0, clk_wiz_0_wiz_clk, and the vga_sync files are the ones not edited at all. 

The top level pong file was where we started, first fixing up our protagonist, the snake. The variables that spawned the bat were changed to make the width and height the same, giving us a base square body. Next, the movement system was overhauled as within the original snake game you are moved in one direction until you press a different input. This was achieved by having a switch case that would set a direction flag when the appropriate button was pressed. There was more work that was needed with movement as you shouldnt be able to go in the same direction you were coming from and you should only have the option to move at certain times. Denying the player from turning around was simple, we just added a flag that will disallow that direction change. The snake moves on a grid, so we made a pseudo grid by only allowing the direction to change at certain times. A move_count integer was added and it would constantly decrement from 8 to 0, then reset to 8. When 8, the direction is then allowed to change, which would let the snake travel 10 pixels. To keep the game feeling smooth we also made this change bufferable by allowing the player to press direction buttons in order to set temporary flags that would change the direction when the cycle allowed change. The other major change made within pong is the addition of making the snake crash and lose. There is an if statement stating if the snake touches any edge of the screen or if a variable from another code is true, then the game resets, setting variables back to their default state. The only other change made was a fair amount of portmapping to allow different parts of the code to talk with each other.

The next file edited is bat_n_ball where we created the ball spawn logic as well as snake growth, self collision, eating, ball spawn, and score. Again, overhauling most of the original code we added an array which is used to draw the snake body. The size of this array is set as an integer variable and can comfortably be around 120, but if synthesizing with this value incrementing slowly, it got to around 500 and could be taken further. By default this array was off, but upon touching the ball, 5 values within the array were changed to true causing the snake to grow. This part of the code is housed within a new process called snake_draw. For self collision we added a section that checks if the head of the snake is touching any part of the array past 3 extensions. This part ignoring the first 3 extensions was a way to combat the possibility for the snake to clip into itself when moving, seeing as you cannot hit the first 3 segments with your head normally, this changes no functionality. If the snake does end up touching itself, then a variable that is portmapped to the crash segment of pong is turned true and causes that code to run. In a similar way to self collision, we made it so if the head touches the ball, it will eat it and grow. The ball then had to spawn in a random location, so we have that happen after a ball is eaten. The RNG of the ball spawn is tied to another file in the project, so it will be explained later, but for now our random values are mapped to here and multiplied by 10. This gives us our ball x and y in increments of 10 and then we spawn it. To disallow the ball from spawning on the snake we implemented a portion that makes the RNG reroll if the new ball spawn were to be on the snake. Also every time the snake eats a ball, it will increment a variable, which is mapped back to pong that then increases our score shown on the board itself. 

Now to describe the way the RNG works, we found an elegant solution to get our pseudo randomness in ball spawn. We made a new file called RNG_table which houses an array from 0 to 137. From index 0 to 78 the values of 1 to 79 are written in an arbitrary order. Values 79 to 137 have values 1 to 59 in an arbitrary order. We have 2  standard logic vectors constantly incrementing and resetting between 2 values on every rising edge, one for the lower indexes and another for the higher ones. When a ball is to be spawned, the values of whatever 2 indexes the vectors are on gets portmapped over to bat_n_ball to be used. 

Finally, we had to change the xdc file in order for all the new inputs we are using to work properly, which is described in the input and output section

## Conclusion

In this project John and Anthony accurately replicated the game snake on a FPGA using VHDL. The work was split fairly evenly between the two group members. Anthony worked on the movement which allowed the player to move the snake around the screen and kept the snake aligned with the desired grid. Anthony also worked on the random number table which allowed the ball to spawn in a random location when eaten. John worked on the snake's length which allowed the snake to get longer as it ate balls and on the counter which tracked the number of balls eaten. Anthony worked on collisions with the walls while John worked on collisions with the snake's body. For when the snake did collide with something John worked on the reset of the game. The final polish was done by Anthony. The work started around early April with the movement and slowly ramped up over the month and into May. By early May a rough outline of the game was made, with some serious features lacking such as collison with the snake's body. Throughout the first week of may the work became nearly daily up until the project was completed on the eleventh. Two major problems we encountered when making this project were how to randomly spawn the ball and how to get the snake to grow. The first was solved by Anthony when he remembered how random numbers were generated in the original doom game. This revelation led him to implementing a random number table that was constantly being cycled through, when called upon it would send out whatever number it was on at that moment. This created a pseudo-randomness that was very useful when spawning the ball. The other issue was making the snake longer. John was able to solve this problem by creating an array that held high and low values, if an element in the array was high then it was to be drawn by the game's graphics if it was low then it was to be ignored. By switching values between high and low John was able to control the length of the snake. This project had many smaller challenges which were each handled as they came resulting in a functioning version of snake.

